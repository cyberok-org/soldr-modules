require("waffi.headers.windows")
local path = require("path")
local lk32 = require("waffi.windows.kernel32")
local adv32 = require("waffi.windows.advapi32")
local ffi = require("ffi")

local exploit_mitigation = { name = "exploit_mitigation" }

local function winerror_tostring(err)
    -- TODO: Get error string from code
    return tostring(err)
end

--- Gets the last error as a string.
---@return string error
local function get_last_error()
    return winerror_tostring(lk32.GetLastError())
end

local policies = {}
ffi.cdef([[
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    ProcessSideChannelIsolationPolicy,
    ProcessUserShadowStackPolicy,
    ProcessRedirectionTrustPolicy,
    ProcessUserPointerAuthPolicy,
    ProcessSEHOPPolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;
]])

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        };
    };
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;
]])
policies.data_execution_prevention = {
    id = ffi.C.ProcessDEPPolicy,
    schema = "PROCESS_MITIGATION_DEP_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;
]])
policies.address_space_layout_randomization = {
    id = ffi.C.ProcessASLRPolicy,
    schema = "PROCESS_MITIGATION_ASLR_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD ProhibitDynamicCode : 1;
      DWORD AllowThreadOptOut : 1;
      DWORD AllowRemoteDowngrade : 1;
      DWORD AuditProhibitDynamicCode : 1;
      DWORD ReservedFlags : 28;
    };
  };
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
]])
policies.dynamic_code = {
    id = ffi.C.ProcessDynamicCodePolicy,
    schema = "PROCESS_MITIGATION_DYNAMIC_CODE_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD RaiseExceptionOnInvalidHandleReference : 1;
      DWORD HandleExceptionsPermanentlyEnabled : 1;
      DWORD ReservedFlags : 30;
    };
  };
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
]])
policies.strict_handle_check = {
    id = ffi.C.ProcessStrictHandleCheckPolicy,
    schema = "PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD DisallowWin32kSystemCalls : 1;
      DWORD AuditDisallowWin32kSystemCalls : 1;
      DWORD ReservedFlags : 30;
    };
  };
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
]])
policies.system_call_disable = {
    id = ffi.C.ProcessSystemCallDisablePolicy,
    schema = "PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD DisableExtensionPoints : 1;
      DWORD ReservedFlags : 31;
    };
  };
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
]])
policies.extension_point_disable = {
    id = ffi.C.ProcessExtensionPointDisablePolicy,
    schema = "PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD EnableControlFlowGuard : 1;
      DWORD EnableExportSuppression : 1;
      DWORD StrictMode : 1;
      DWORD EnableXfg : 1;
      DWORD EnableXfgAuditMode : 1;
      DWORD ReservedFlags : 27;
    };
  };
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
]])
policies.control_flow_guard = {
    id = ffi.C.ProcessControlFlowGuardPolicy,
    schema = "PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD MicrosoftSignedOnly : 1;
      DWORD StoreSignedOnly : 1;
      DWORD MitigationOptIn : 1;
      DWORD AuditMicrosoftSignedOnly : 1;
      DWORD AuditStoreSignedOnly : 1;
      DWORD ReservedFlags : 27;
    };
  };
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
]])
policies.binary_signature = {
    id = ffi.C.ProcessSignaturePolicy,
    schema = "PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD DisableNonSystemFonts : 1;
      DWORD AuditNonSystemFontLoading : 1;
      DWORD ReservedFlags : 30;
    };
  };
} PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;
]])
policies.font_disable = {
    id = ffi.C.ProcessFontDisablePolicy,
    schema = "PROCESS_MITIGATION_FONT_DISABLE_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD NoRemoteImages : 1;
      DWORD NoLowMandatoryLabelImages : 1;
      DWORD PreferSystem32Images : 1;
      DWORD AuditNoRemoteImages : 1;
      DWORD AuditNoLowMandatoryLabelImages : 1;
      DWORD ReservedFlags : 27;
    };
  };
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;
]])
policies.image_load = {
    id = ffi.C.ProcessImageLoadPolicy,
    schema = "PROCESS_MITIGATION_IMAGE_LOAD_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD EnforceRedirectionTrust : 1;
      DWORD AuditRedirectionTrust : 1;
      DWORD ReservedFlags : 30;
    };
  };
} PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY, *PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
]])
policies.redirection_trust = {
    id = ffi.C.ProcessRedirectionTrustPolicy,
    schema = "PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD SmtBranchTargetIsolation : 1;
      DWORD IsolateSecurityDomain : 1;
      DWORD DisablePageCombine : 1;
      DWORD SpeculativeStoreBypassDisable : 1;
      DWORD RestrictCoreSharing : 1;
      DWORD ReservedFlags : 27;
    };
  };
} PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
]])
policies.side_channel_isolation = {
    id = ffi.C.ProcessSideChannelIsolationPolicy,
    schema = "PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY",
}

ffi.cdef([[
typedef struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD EnableUserShadowStack : 1;
      DWORD AuditUserShadowStack : 1;
      DWORD SetContextIpValidation : 1;
      DWORD AuditSetContextIpValidation : 1;
      DWORD EnableUserShadowStackStrictMode : 1;
      DWORD BlockNonCetBinaries : 1;
      DWORD BlockNonCetBinariesNonEhcont : 1;
      DWORD AuditBlockNonCetBinaries : 1;
      DWORD CetDynamicApisOutOfProcOnly : 1;
      DWORD SetContextIpValidationRelaxedMode : 1;
      DWORD ReservedFlags : 22;
    };
  };
} PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY, *PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
]])
policies.user_shadow_stack = {
    id = ffi.C.ProcessUserShadowStackPolicy,
    schema = "PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY",
}

ffi.cdef([[
BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy,
                                PVOID lpBuffer, SIZE_T dwLength);

BOOL GetProcessMitigationPolicy(HANDLE hProcess,
                                PROCESS_MITIGATION_POLICY MitigationPolicy,
                                PVOID lpBuffer, SIZE_T dwLength);
]])

---Applies the `config` for the specified mitigation policy `name`
---and returns the previous configuration.
---@param name string name of the mitigation policy
---@param config table configuration to apply
---@return table|nil old configuration
---@return string|nil error string explaining the problem, if any
local function apply_policy(name, config)
    local policy = assert(policies[name], string.format("no policy '%s'", name))
    local buf = ffi.new(policy.schema)
    local len = ffi.sizeof(policy.schema)
    local process = lk32.GetCurrentProcess()
    local ret = ffi.C.GetProcessMitigationPolicy(process, policy.id, buf, len)
    if not ret then
        return nil, get_last_error()
    end
    local old_config = {}
    for key, value in pairs(config) do
        old_config[key] = (buf[key] ~= 0)
        buf[key] = value
    end
    ret = ffi.C.SetProcessMitigationPolicy(policy.id, buf, len)
    if not ret then
        return nil, get_last_error()
    end
    return old_config
end

function exploit_mitigation.set_process_policies(policies)
    local old_profile = {}
    for name, params in pairs(policies) do
        local old_params, err = apply_policy(name, params)
        if not old_params then
            -- TODO: rollback all applied policies and return error
            return nil, err
        end
        old_profile[name] = old_params
    end
    return old_profile
end

local function multiByteToWideChar(str)
    local ptr, size = ffi.cast("const char*", str), #str

    local nsize = lk32.MultiByteToWideChar(lk32.CP_UTF8, 0, ptr, size, nil, 0)
    if nsize <= 0 then
        return nil, 0
    end

    local wstr = ffi.new("wchar_t[?]", nsize + 1)
    nsize = lk32.MultiByteToWideChar(lk32.CP_UTF8, 0, ptr, size, wstr, nsize)
    return wstr, nsize
end

local function to_array(bytes, size)
    local arr = {}
    for i = 1, size do
        arr[i] = bytes[i - 1]
    end
    return arr
end

function exploit_mitigation.apply_executable_policy(exe)
    local old_exe = { name = assert(exe.name, "executable must be specified") }
    local exe_subkey = multiByteToWideChar(
        string.format(
            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
            path.file(exe.name)
        )
    )
    local options_key = multiByteToWideChar("MitigationOptions")

    local opts_value = ffi.new("BYTE[24]")
    local opts_size = ffi.new("DWORD[1]", ffi.sizeof(opts_value))
    local RRF_RT_REG_BINARY = 0x00000008
    local HKEY_LOCAL_MACHINE = ffi.cast("HKEY", adv32.HKEY_LOCAL_MACHINE)
    local err = adv32.RegGetValueW(
        HKEY_LOCAL_MACHINE,
        exe_subkey,
        options_key,
        RRF_RT_REG_BINARY,
        nil,
        opts_value,
        opts_size
    )
    if err ~= lk32.ERROR_SUCCESS and err ~= lk32.ERROR_FILE_NOT_FOUND then
        return nil, winerror_tostring(err)
    elseif err == lk32.ERROR_SUCCESS then
        old_exe.mitigation_options = to_array(opts_value, opts_size[0])
    end
    if exe.mitigation_options then
        err = adv32.RegSetKeyValueW(
            HKEY_LOCAL_MACHINE,
            exe_subkey,
            options_key,
            adv32.REG_BINARY,
            ffi.new("BYTE[24]", exe.mitigation_options),
            #exe.mitigation_options
        )
        if err ~= lk32.ERROR_SUCCESS then
            return nil, winerror_tostring(err)
        end
    else
        err = adv32.RegDeleteKeyValueW(
            HKEY_LOCAL_MACHINE,
            exe_subkey,
            options_key
        )
        if err ~= lk32.ERROR_SUCCESS and err ~= lk32.ERROR_FILE_NOT_FOUND then
            return nil, winerror_tostring(err)
        end
    end
    return old_exe
end

function exploit_mitigation.set_executable_policies(executables)
    local old_profile = {}
    for _, exe in ipairs(executables) do
        local old_exe, err = exploit_mitigation.apply_executable_policy(exe)
        if not old_exe then
            -- TODO: rollback all applied policies and return error
            return nil, err
        end
        table.insert(old_profile, old_exe)
    end
    return old_profile
end

function exploit_mitigation.apply(profile)
    local old_profile = {}
    local policies = profile.process
    if policies then
        local prev, err = exploit_mitigation.set_process_policies(policies)
        if not prev then
            -- TODO: rollback all applied policies and return error
            return nil, err
        end
        old_profile.process = prev
    end

    local exes = profile.executables
    if exes then
        local prev, err = exploit_mitigation.set_executable_policies(exes)
        if not prev then
            -- TODO: rollback all applied policies and return error
            return nil, err
        end
        old_profile.executables = prev
    end
    return old_profile
end

return exploit_mitigation
