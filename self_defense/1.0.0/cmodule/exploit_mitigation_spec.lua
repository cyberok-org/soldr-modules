local strategy = require("exploit_mitigation")
local say = require("say")

local POLICIES = {
    data_execution_prevention = {
        Enable = true,
        Permanent = true,
        DisableAtlThunkEmulation = true,
    },
    address_space_layout_randomization = {
        EnableBottomUpRandomization = true,
        EnableForceRelocateImages = true,
        EnableHighEntropy = true,
        DisallowStrippedImages = true,
    },
    dynamic_code = {
        ProhibitDynamicCode = false, -- causes the lua to crash
        AllowThreadOptOut = false,
        AllowRemoteDowngrade = false,
        AuditProhibitDynamicCode = true,
    },
    strict_handle_check = {
        RaiseExceptionOnInvalidHandleReference = true,
        HandleExceptionsPermanentlyEnabled = true,
    },
    system_call_disable = {
        DisallowWin32kSystemCalls = false,
        AuditDisallowWin32kSystemCalls = false,
    },
    extension_point_disable = {
        DisableExtensionPoints = true,
    },
    control_flow_guard = {
        EnableControlFlowGuard = false,
        EnableExportSuppression = false,
        StrictMode = false,
        EnableXfg = false,
        EnableXfgAuditMode = false,
    },
    binary_signature = {
        MicrosoftSignedOnly = false,
        StoreSignedOnly = false,
        MitigationOptIn = false,
        AuditMicrosoftSignedOnly = false,
        AuditStoreSignedOnly = false,
    },
    font_disable = {
        DisableNonSystemFonts = true,
        AuditNonSystemFontLoading = true,
    },
    image_load = {
        NoRemoteImages = true,
        NoLowMandatoryLabelImages = true,
        PreferSystem32Images = true,
        AuditNoRemoteImages = true,
        AuditNoLowMandatoryLabelImages = true,
    },
    redirection_trust = {
        EnforceRedirectionTrust = true,
        AuditRedirectionTrust = true,
    },
    side_channel_isolation = {
        SmtBranchTargetIsolation = true,
        IsolateSecurityDomain = true,
        DisablePageCombine = true,
        SpeculativeStoreBypassDisable = true,
        RestrictCoreSharing = true,
    },
    user_shadow_stack = {
        EnableUserShadowStack = true,
        AuditUserShadowStack = true,
        SetContextIpValidation = true,
        AuditSetContextIpValidation = true,
        EnableUserShadowStackStrictMode = true,
        BlockNonCetBinaries = true,
        BlockNonCetBinariesNonEhcont = true,
        CetDynamicApisOutOfProcOnly = true,
        SetContextIpValidationRelaxedMode = false,
    },
}

local EXECUTABLES = {
    {
        name = "hardened.exe",
        flags = 0,
    },
}

local PROFILE = {
    process = POLICIES,
    executables = EXECUTABLES,
}

local function has_property(state, arguments)
    local property = arguments[1]
    local table = arguments[2]
    for key, value in pairs(table) do
        if key == property then
            return true
        end
    end
    return false
end

say:set_namespace("en")
say:set("assertion.has_property.positive", "Expected property %s in:\n%s")
say:set(
    "assertion.has_property.negative",
    "Expected property %s to not be in:\n%s"
)
assert:register(
    "assertion",
    "has_property",
    has_property,
    "assertion.has_property.positive",
    "assertion.has_property.negative"
)

describe("set_process_policies", function()
    it("returns previous profile on success", function()
        local old_profile = strategy.set_process_policies(POLICIES)

        assert.is_table(old_profile)
        for policy_name, policy_params in pairs(POLICIES) do
            assert.has_property(policy_name, old_profile)
            local old_params = old_profile[policy_name]
            assert.is_table(old_params)
            for key in pairs(policy_params) do
                assert.has_property(key, old_params)
                assert.equal(type(policy_params[key]), type(old_params[key]))
            end
        end
    end)
end)

describe("set_executable_policies", function()
    it("returns previouse profile on success", function()
        local old_profile = strategy.set_executable_policies(EXECUTABLES)

        assert.is_table(old_profile)
        for idx, executable in ipairs(EXECUTABLES) do
            local old_executable = old_profile[idx]
            assert.is_table(old_executable)
            assert.has_property("name", old_profile[idx])
            assert.same(executable.name, old_profile[idx].name)
        end
    end)
end)

describe("apply", function()
    it("returns previous profile on successfull applience", function()
        local old_profile = strategy.apply(PROFILE)

        assert.is_table(old_profile)
        assert.has_property("process", old_profile)
        assert.has_property("executables", old_profile)
    end)
end)
